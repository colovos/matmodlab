import scipy
import numpy as np
from numpy import zeros, array, eye, asarray

# II1: I[i,j] I[k,l]
II1 = array([1.0, 1.0, 1.0, 0.0, 0.0, 0.0,
             1.0, 1.0, 1.0, 0.0, 0.0, 0.0,
             1.0, 1.0, 1.0, 0.0, 0.0, 0.0,
             0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
             0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
             0.0, 0.0, 0.0, 0.0, 0.0, 0.0]).reshape(6,6)

# II2: I[i,k] I[j,l]
II2 = array([1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0, 0.0, 0.0,
             0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
             0.0, 0.0, 0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 0.0, 0.0, 1.0]).reshape(6,6)

# II3: I[i,l] I[j,k]
II3 = array([1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0, 0.0, 0.0,
             0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
             0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
             0.0, 0.0, 0.0, 0.0, 0.0, 0.0]).reshape(6,6)

II4 = (II2 + II3) / 2

# II5 = (I[i,k] I[j,l] + I[i,l] I[j,k]) / 2
II5 = array([1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
             0.0, 1.0, 0.0, 0.0, 0.0, 0.0,
             0.0, 0.0, 1.0, 0.0, 0.0, 0.0,
             0.0, 0.0, 0.0, 0.5, 0.0, 0.0,
             0.0, 0.0, 0.0, 0.0, 0.5, 0.0,
             0.0, 0.0, 0.0, 0.0, 0.0, 0.5]).reshape(6,6)

def symsq(F):
    """Returns X = dot(F.T, F)"""
    X = zeros(6)
    X[0] = F[0]**2 + F[3]**2 + F[6]**2
    X[1] = F[1]**2 + F[4]**2 + F[7]**2
    X[2] = F[2]**2 + F[5]**2 + F[8]**2
    X[3] = F[0]*F[1] + F[3]*F[4] + F[6]*F[7]
    X[4] = F[1]*F[2] + F[4]*F[5] + F[7]*F[8]
    X[5] = F[0]*F[2] + F[3]*F[5] + F[6]*F[8]
    return X

def det(A):
    if A.size == 6:
        X = (  A[0]*A[1]*A[2] - A[0]*A[4]*A[4]
             - A[1]*A[5]*A[5] - A[2]*A[3]*A[3]
             + 2*A[3]*A[4]*A[5])
    else:
        X = (  A[0]*A[4]*A[8] - A[0]*A[5]*A[7]
             - A[1]*A[3]*A[8] + A[1]*A[5]*A[6]
             + A[2]*A[3]*A[7] - A[2]*A[4]*A[6])
    return X

def invariants(A, itype=0):
    I1 = A[0] + A[1] + A[2]
    I2 = ((A[0] + A[1] + A[2])**2/2
          -A[0]**2/2 - A[1]**2/2 - A[2]**2/2 - A[3]**2 - A[4]**2 - A[5]**2)
    I3 = det(A)
    return I1, I2, I3

def push(F, A):
    """Push transformation: F * A * F.T / J"""
    if A.size == 6:
        return push6(F, A)
    if A.size == 36:
        return push66(F, A)
    raise NotImplementedError

def push6(F, A):
    X = zeros(6)
    X[0] = (F[0]*(A[0]*F[0] + A[3]*F[1] + A[5]*F[2])
          + F[1]*(A[1]*F[1] + A[3]*F[0] + A[4]*F[2])
          + F[2]*(A[2]*F[2] + A[4]*F[1] + A[5]*F[0]))
    X[1] = (F[3]*(A[0]*F[3] + A[3]*F[4] + A[5]*F[5])
          + F[4]*(A[1]*F[4] + A[3]*F[3] + A[4]*F[5])
          + F[5]*(A[2]*F[5] + A[4]*F[4] + A[5]*F[3]))
    X[2] = (F[6]*(A[0]*F[6] + A[3]*F[7] + A[5]*F[8])
          + F[7]*(A[1]*F[7] + A[3]*F[6] + A[4]*F[8])
          + F[8]*(A[2]*F[8] + A[4]*F[7] + A[5]*F[6]))
    X[3] = (F[3]*(A[0]*F[0] + A[3]*F[1] + A[5]*F[2])
          + F[4]*(A[1]*F[1] + A[3]*F[0] + A[4]*F[2])
          + F[5]*(A[2]*F[2] + A[4]*F[1] + A[5]*F[0]))
    X[4] = (F[6]*(A[0]*F[3] + A[3]*F[4] + A[5]*F[5])
          + F[7]*(A[1]*F[4] + A[3]*F[3] + A[4]*F[5])
          + F[8]*(A[2]*F[5] + A[4]*F[4] + A[5]*F[3]))
    X[5] = (F[6]*(A[0]*F[0] + A[3]*F[1] + A[5]*F[2])
          + F[7]*(A[1]*F[1] + A[3]*F[0] + A[4]*F[2])
          + F[8]*(A[2]*F[2] + A[4]*F[1] + A[5]*F[0]))
    return X / det(F)

def push66(F, A):
    FF = symleaf(F)
    X = np.dot(np.dot(FF, A), FF.T)
    return X / det(F)

def inv(A):
    if A.size == 6:
        X = zeros(6)
        X[0] = (-(A[0]*A[1] - A[3]**2)*(-A[3]*(A[4] - A[3]*A[5]/A[0])
               /(A[0]*(A[1] - A[3]**2/A[0])) + A[5]/A[0])*(A[3]*(A[4]
               - A[3]*A[5]/A[0])/(A[0]*(A[1] - A[3]**2/A[0]))
               - A[5]/A[0])/(A[0]*A[1]*A[2] - A[0]*A[4]**2 - A[1]*A[5]**2
               - A[2]*A[3]**2 + 2*A[3]*A[4]*A[5]) + 1/A[0]
               + A[3]**2/(A[0]**2*(A[1] - A[3]**2/A[0])))
        X[1] = (1/(A[1] - A[3]**2/A[0]) + (A[4] - A[3]*A[5]/A[0])**2
                *(A[0]*A[1] - A[3]**2)/((A[1] - A[3]**2/A[0])**2*(A[0]*A[1]*A[2]
                - A[0]*A[4]**2 - A[1]*A[5]**2 - A[2]*A[3]**2
                + 2*A[3]*A[4]*A[5])))
        X[2] = ((A[0]*A[1] - A[3]**2)/(A[0]*A[1]*A[2] - A[0]*A[4]**2
                - A[1]*A[5]**2 - A[2]*A[3]**2 + 2*A[3]*A[4]*A[5]))
        X[3] = ((A[4] - A[3]*A[5]/A[0])*(A[0]*A[1] - A[3]**2)*(-A[3]
                *(A[4] - A[3]*A[5]/A[0])/(A[0]*(A[1] - A[3]**2/A[0]))
                + A[5]/A[0])/((A[1] - A[3]**2/A[0])*(A[0]*A[1]*A[2]
                - A[0]*A[4]**2 - A[1]*A[5]**2 - A[2]*A[3]**2
                + 2*A[3]*A[4]*A[5])) - A[3]/(A[0]*(A[1] - A[3]**2/A[0])))
        X[4] = (-(A[4] - A[3]*A[5]/A[0])*(A[0]*A[1] - A[3]**2)/((A[1]
                - A[3]**2/A[0])*(A[0]*A[1]*A[2] - A[0]*A[4]**2 - A[1]*A[5]**2
                - A[2]*A[3]**2 + 2*A[3]*A[4]*A[5])))
        X[5] = (-(A[0]*A[1] - A[3]**2)*(-A[3]*(A[4] - A[3]*A[5]/A[0])/(A[0]*(A[1]
                - A[3]**2/A[0])) + A[5]/A[0])/(A[0]*A[1]*A[2]
                - A[0]*A[4]**2 - A[1]*A[5]**2 - A[2]*A[3]**2 + 2*A[3]*A[4]*A[5]))
    else:
        X = np.linalg.inv(A.reshape(3,3))
        X = X.reshape(9)
    return X

def dyad(A, B):
    if A.size == 6 and B.size == 6:
        X = zeros((6,6))
        X[0,0] = A[0] * B[0]
        X[0,1] = A[0] * B[1]
        X[0,2] = A[0] * B[2]
        X[0,3] = A[0] * B[3]
        X[0,4] = A[0] * B[4]
        X[0,5] = A[0] * B[5]
        X[1,0] = A[1] * B[0]
        X[1,1] = A[1] * B[1]
        X[1,2] = A[1] * B[2]
        X[1,3] = A[1] * B[3]
        X[1,4] = A[1] * B[4]
        X[1,5] = A[1] * B[5]
        X[2,0] = A[2] * B[0]
        X[2,1] = A[2] * B[1]
        X[2,2] = A[2] * B[2]
        X[2,3] = A[2] * B[3]
        X[2,4] = A[2] * B[4]
        X[2,5] = A[2] * B[5]
        X[3,0] = A[3] * B[0]
        X[3,1] = A[3] * B[1]
        X[3,2] = A[3] * B[2]
        X[3,3] = A[3] * B[3]
        X[3,4] = A[3] * B[4]
        X[3,5] = A[3] * B[5]
        X[4,0] = A[4] * B[0]
        X[4,1] = A[4] * B[1]
        X[4,2] = A[4] * B[2]
        X[4,3] = A[4] * B[3]
        X[4,4] = A[4] * B[4]
        X[4,5] = A[4] * B[5]
        X[5,0] = A[5] * B[0]
        X[5,1] = A[5] * B[1]
        X[5,2] = A[5] * B[2]
        X[5,3] = A[5] * B[3]
        X[5,4] = A[5] * B[4]
        X[5,5] = A[5] * B[5]
    elif A.size == 3 and B.size == 3:
        X = zeros(6)
        X[0] = A[0] * B[0]
        X[1] = A[1] * B[1]
        X[2] = A[2] * B[2]
        X[3] = A[0] * B[1]
        X[4] = A[1] * B[2]
        X[5] = A[0] * B[2]
    else:
        raise NotImplementedError
    return X

def symshuffle(A, B):
    # Xijkl = .5 (Aik Bjl + Ail Bjk)
    X = zeros((6,6))
    if A.size == 6 and B.size == 6:
        X[0,0] = (A[0] * B[0] + A[0] * B[0]) / 2.
        X[0,1] = (A[3] * B[3] + A[3] * B[3]) / 2.
        X[0,2] = (A[5] * B[5] + A[5] * B[5]) / 2.
        X[0,3] = (A[0] * B[3] + A[3] * B[0]) / 2.
        X[0,4] = (A[3] * B[5] + A[5] * B[3]) / 2.
        X[0,5] = (A[0] * B[5] + A[5] * B[0]) / 2.
        X[1,0] = (A[3] * B[3] + A[3] * B[3]) / 2.
        X[1,1] = (A[1] * B[1] + A[1] * B[1]) / 2.
        X[1,2] = (A[4] * B[4] + A[4] * B[4]) / 2.
        X[1,3] = (A[3] * B[1] + A[1] * B[3]) / 2.
        X[1,4] = (A[1] * B[4] + A[4] * B[1]) / 2.
        X[1,5] = (A[3] * B[4] + A[4] * B[3]) / 2.
        X[2,0] = (A[5] * B[5] + A[5] * B[5]) / 2.
        X[2,1] = (A[4] * B[4] + A[4] * B[4]) / 2.
        X[2,2] = (A[2] * B[2] + A[2] * B[2]) / 2.
        X[2,3] = (A[5] * B[4] + A[4] * B[5]) / 2.
        X[2,4] = (A[4] * B[2] + A[2] * B[4]) / 2.
        X[2,5] = (A[5] * B[2] + A[2] * B[5]) / 2.
        X[3,0] = (A[0] * B[3] + A[0] * B[3]) / 2.
        X[3,1] = (A[3] * B[1] + A[3] * B[1]) / 2.
        X[3,2] = (A[5] * B[4] + A[5] * B[4]) / 2.
        X[3,3] = (A[0] * B[1] + A[3] * B[3]) / 2.
        X[3,4] = (A[3] * B[4] + A[5] * B[1]) / 2.
        X[3,5] = (A[0] * B[4] + A[5] * B[3]) / 2.
        X[4,0] = (A[3] * B[5] + A[3] * B[5]) / 2.
        X[4,1] = (A[1] * B[4] + A[1] * B[4]) / 2.
        X[4,2] = (A[4] * B[2] + A[4] * B[2]) / 2.
        X[4,3] = (A[3] * B[4] + A[1] * B[5]) / 2.
        X[4,4] = (A[1] * B[2] + A[4] * B[4]) / 2.
        X[4,5] = (A[3] * B[2] + A[4] * B[5]) / 2.
        X[5,0] = (A[0] * B[5] + A[0] * B[5]) / 2.
        X[5,1] = (A[3] * B[4] + A[3] * B[4]) / 2.
        X[5,2] = (A[5] * B[2] + A[5] * B[2]) / 2.
        X[5,3] = (A[0] * B[4] + A[3] * B[5]) / 2.
        X[5,4] = (A[3] * B[2] + A[5] * B[4]) / 2.
        X[5,5] = (A[0] * B[2] + A[5] * B[5]) / 2.
    else:
        raise NotImplementedError
    return X

def symleaf(F):
    """ COMPUTE A 6X6 MANDEL MATRIX THAT IS THE SYM-LEAF TRANSFORMATION OF THE
    INPUT 3X3 MATRIX F.

    Parameters
    ----------
    F : ANY 3X3 MATRIX (IN CONVENTIONAL 3X3 STORAGE)

    Returns
    -------
    X : 6X6 MANDEL MATRIX FOR THE SYM-LEAF TRANSFORMATION MATRIX

    Notes
    -----
    IF A IS ANY SYMMETRIC TENSOR, AND IF {A} IS ITS 6X1 MANDEL ARRAY, THEN THE
    6X1 MANDEL ARRAY FOR THE TENSOR B=F.A.TRANSPOSE[F] MAY BE COMPUTED BY

                          {B}=[FF]{A}

    IF F IS A DEFORMATION F, THEN B IS THE "PUSH" (SPATIAL) TRANSFORMATION OF
    THE REFERENCE TENSOR A IF F IS Inverse[F], THEN B IS THE "PULL"
    (REFERENCE) TRANSFORMATION OF THE SPATIAL TENSOR A, AND THEREFORE B WOULD
    BE Inverse[FF]{A}.

    IF F IS A ROTATION, THEN B IS THE ROTATION OF A, AND
    FF WOULD BE BE A 6X6 ORTHOGONAL MATRIX, JUST AS IS F

    """
    X = zeros((6,6))
    F = F.reshape(3,3)
    X[0,0] = F[0,0] * F[0,0]
    X[0,1] = F[0,1] * F[0,1]
    X[0,2] = F[0,2] * F[0,2]
    X[0,3] = F[0,0] * F[0,1] + F[0,1] * F[0,0]
    X[0,4] = F[0,1] * F[0,2] + F[0,2] * F[0,1]
    X[0,5] = F[0,0] * F[0,2] + F[0,2] * F[0,0]
    X[1,0] = F[1,0] * F[1,0]
    X[1,1] = F[1,1] * F[1,1]
    X[1,2] = F[1,2] * F[1,2]
    X[1,3] = F[1,0] * F[1,1] + F[1,1] * F[1,0]
    X[1,4] = F[1,1] * F[1,2] + F[1,2] * F[1,1]
    X[1,5] = F[1,0] * F[1,2] + F[1,2] * F[1,0]
    X[2,0] = F[2,0] * F[2,0]
    X[2,1] = F[2,1] * F[2,1]
    X[2,2] = F[2,2] * F[2,2]
    X[2,3] = F[2,0] * F[2,1] + F[2,1] * F[2,0]
    X[2,4] = F[2,1] * F[2,2] + F[2,2] * F[2,1]
    X[2,5] = F[2,0] * F[2,2] + F[2,2] * F[2,0]
    X[3,0] = F[0,0] * F[1,0] + F[1,0] * F[0,0]
    X[3,1] = F[0,1] * F[1,1] + F[1,1] * F[0,1]
    X[3,2] = F[0,2] * F[1,2] + F[1,2] * F[0,2]
    X[3,3] = F[0,0] * F[1,1] + F[0,1] * F[1,0]
    X[3,4] = F[0,1] * F[1,2] + F[0,2] * F[1,1]
    X[3,5] = F[0,0] * F[1,2] + F[0,2] * F[1,0]
    X[4,0] = F[1,0] * F[2,0] + F[2,0] * F[1,0]
    X[4,1] = F[1,1] * F[2,1] + F[2,1] * F[1,1]
    X[4,2] = F[1,2] * F[2,2] + F[2,2] * F[1,2]
    X[4,3] = F[1,0] * F[2,1] + F[1,1] * F[2,0]
    X[4,4] = F[1,1] * F[2,2] + F[1,2] * F[2,1]
    X[4,5] = F[1,0] * F[2,2] + F[1,2] * F[2,0]
    X[5,0] = F[0,0] * F[2,0] + F[2,0] * F[0,0]
    X[5,1] = F[0,1] * F[2,1] + F[2,1] * F[0,1]
    X[5,2] = F[0,2] * F[2,2] + F[2,2] * F[0,2]
    X[5,3] = F[0,0] * F[2,1] + F[0,1] * F[2,0]
    X[5,4] = F[0,1] * F[2,2] + F[0,2] * F[2,1]
    X[5,5] = F[0,0] * F[2,2] + F[0,2] * F[2,0]
    return X
