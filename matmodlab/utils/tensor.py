import numpy as np
from numpy import array, zeros
"""tensor.py

THIS FILE IS AUTOMATICALLY GENERATED - DO NOT EDIT IT DIRECTLY!

Constants and functions having to deal with 3D symmetric and nonsymmetric 
second order tensors fourth-order tensors with minor and major symmetries.  
All of the functions are written with the following assumptions:

o Symmetric second-order tensors are stored as arrays of length 6 with the 
  following component ordering
      
  [XX, YY, ZZ, XY, YZ, ZZ]
      
o Nonsymmetric second-order tensors are stored as arrays of length 9 with the 
  following component ordering
    
  [XX, XY, XZ, YX, YY, YZ, ZX, ZY, ZZ]
      
o Fourth-order tensors are stored as 6x6 matrices using the same component 
  transformations as second-order symmetric tensors
      
"""
# Fourth-order "identities"
# II1: I[i,j] I[k,l]
II1 = (array([1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 1.0,
       1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
       0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]).reshape(6,6))
# II2: I[i,k] I[j,l]
II2 = (array([1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
       0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
       0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]).reshape(6,6))
# II3: I[i,l] I[j,k]
II3 = (array([1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
       0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
       0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]).reshape(6,6))
II4 = (II2 + II3) / 2
# II5 = (I[i,k] I[j,l] + I[i,l] I[j,k]) / 2
II5 = (array([1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
       0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0,
       0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.5]).reshape(6,6))
# Second-order identities
I6 = array([1., 1., 1., 0., 0., 0.])
I9 = array([1., 0., 0., 0., 1., 0., 0., 0., 1.])
I3x3 = I9.reshape(3,3)
def symsq(F):
    """ Computes dot(F.T, F)"""
    X = zeros(6)
    X[0] = F[0]**2 + F[3]**2 + F[6]**2
    X[1] = F[1]**2 + F[4]**2 + F[7]**2
    X[2] = F[2]**2 + F[5]**2 + F[8]**2
    X[3] = F[0]*F[1] + F[3]*F[4] + F[6]*F[7]
    X[4] = F[1]*F[2] + F[4]*F[5] + F[7]*F[8]
    X[5] = F[0]*F[2] + F[3]*F[5] + F[6]*F[8]
    return X
def det(A):
    """ Computes the determininant of A"""
    if A.size == 6:
        X = (A[0]*A[1]*A[2] - A[0]*A[4]**2 - A[1]*A[5]**2 - A[2]*A[3]**2 +
             2*A[3]*A[4]*A[5])
    else:
        X = (A[0]*A[4]*A[8] - A[0]*A[5]*A[7] - A[1]*A[3]*A[8] + A[1]*A[5]*A[6]
             + A[2]*A[3]*A[7] - A[2]*A[4]*A[6])
    return X
def ddot(A, B):
    """ Computes A:B"""
    if B.size == 6 and A.size == 9:
        A, B = B, A
    if A.size == 6 and B.size == 6:
        X = (A[0]*B[0] + A[3]*B[3] + A[5]*B[5] + A[3]*B[3] + A[1]*B[1] +
             A[4]*B[4] + A[5]*B[5] + A[4]*B[4] + A[2]*B[2])
    elif A.size == 6 and B.size == 9:
        X = (A[0]*B[0] + A[3]*B[1] + A[5]*B[2] + A[3]*B[3] + A[1]*B[4] +
             A[4]*B[5] + A[5]*B[6] + A[4]*B[7] + A[2]*B[8])
    elif A.size == 9 and B.size == 9:
        X = (A[0]*B[0] + A[1]*B[1] + A[2]*B[2] + A[3]*B[3] + A[4]*B[4] +
             A[5]*B[5] + A[6]*B[6] + A[7]*B[7] + A[8]*B[8])
    else:
        raise NotImplementedError
    return X
def trace(A, metric=None):
    """Computes the trace of a tensor"""
    if A.size not in (6, 9):
        raise NotImplementedError
    if A.size == 6 and metric is None:
        metric, X = I6, I6
    elif A.size == 9 and metric is None:
        metric, X = I9, I9
    else:
        X = inv(metric)
    return ddot(A, metric)
def iso(A, metric=None):
    """Computes the isotropic part of a tensor"""
    if A.size not in (6, 9):
        raise NotImplementedError
    if A.size == 6 and metric is None:
        metric, X = I6, I6
    elif A.size == 9 and metric is None:
        metric, X = I9, I9
    else:
        X = inv(metric)
    return trace(A, metric) / 3. * X
def dev(A, metric=None):
    """Computes the isotropic part of a tensor"""
    return A - iso(A, metric=metric)
def mag(A):
    """Computes the magnitude of a tensor"""
    return np.sqrt(ddot(A, A))
def invariants(A, itype=0):
    """ Computes the invariants of A

        Parameters
        ----------
        itype : int
            Type of invariants to compute
            
        Returns
        -------
        A, B, C : float
        
        Notes
        -----
        The values A, B, C depend on itype:
            =0 -> I1, I2, I3
            =1 -> I1, J2, J3
    """

    if itype == 0:
        I1 = A[0] + A[1] + A[2]
        I2 = (-A[0]**2/2 - A[1]**2/2 - A[2]**2/2 - A[3]**2 - A[4]**2 - A[5]**2
              + (A[0] + A[1] + A[2])**2/2)
        I3 = det(A)
        A, B, C = I1, I2, I3
    elif itype == 1:
        I1 = A[0] + A[1] + A[2]
        J2 = (A[3]**2 + A[4]**2 + A[5]**2 + (-A[0]/3 - A[1]/3 + 2*A[2]/3)**2/2
              + (-A[0]/3 + 2*A[1]/3 - A[2]/3)**2/2 + (2*A[0]/3 - A[1]/3 -
              A[2]/3)**2/2)
        J3 = (2*A[3]*(A[3]*(-A[0]/3 + 2*A[1]/3 - A[2]/3) + A[3]*(2*A[0]/3 -
              A[1]/3 - A[2]/3) + A[4]*A[5])/3 + 2*A[4]*(A[3]*A[5] +
              A[4]*(-A[0]/3 - A[1]/3 + 2*A[2]/3) + A[4]*(-A[0]/3 + 2*A[1]/3 -
              A[2]/3))/3 + 2*A[5]*(A[3]*A[4] + A[5]*(-A[0]/3 - A[1]/3 +
              2*A[2]/3) + A[5]*(2*A[0]/3 - A[1]/3 - A[2]/3))/3 + (-A[0]/3 -
              A[1]/3 + 2*A[2]/3)*(A[4]**2 + A[5]**2 + (-A[0]/3 - A[1]/3 +
              2*A[2]/3)**2)/3 + (-A[0]/3 + 2*A[1]/3 - A[2]/3)*(A[3]**2 +
              A[4]**2 + (-A[0]/3 + 2*A[1]/3 - A[2]/3)**2)/3 + (2*A[0]/3 -
              A[1]/3 - A[2]/3)*(A[3]**2 + A[5]**2 + (2*A[0]/3 - A[1]/3 -
              A[2]/3)**2)/3)
        A, B, C = I1, J2, J3
    else:
        raise NotImplementedError
    return A, B, C
def push(F, A):
    """Computes the push operation F A F.T / J"""
    if A.size == 6:
        return push6(F, A)
    elif A.size == 36:
        return push66(F, A)
    raise NotImplementedError
def push6(F, A):
    X = zeros(6)
    X[0] = (F[0]*(A[0]*F[0] + A[3]*F[1] + A[5]*F[2]) + F[1]*(A[1]*F[1] +
            A[3]*F[0] + A[4]*F[2]) + F[2]*(A[2]*F[2] + A[4]*F[1] + A[5]*F[0]))
    X[1] = (F[3]*(A[0]*F[3] + A[3]*F[4] + A[5]*F[5]) + F[4]*(A[1]*F[4] +
            A[3]*F[3] + A[4]*F[5]) + F[5]*(A[2]*F[5] + A[4]*F[4] + A[5]*F[3]))
    X[2] = (F[6]*(A[0]*F[6] + A[3]*F[7] + A[5]*F[8]) + F[7]*(A[1]*F[7] +
            A[3]*F[6] + A[4]*F[8]) + F[8]*(A[2]*F[8] + A[4]*F[7] + A[5]*F[6]))
    X[3] = (F[3]*(A[0]*F[0] + A[3]*F[1] + A[5]*F[2]) + F[4]*(A[1]*F[1] +
            A[3]*F[0] + A[4]*F[2]) + F[5]*(A[2]*F[2] + A[4]*F[1] + A[5]*F[0]))
    X[4] = (F[6]*(A[0]*F[3] + A[3]*F[4] + A[5]*F[5]) + F[7]*(A[1]*F[4] +
            A[3]*F[3] + A[4]*F[5]) + F[8]*(A[2]*F[5] + A[4]*F[4] + A[5]*F[3]))
    X[5] = (F[6]*(A[0]*F[0] + A[3]*F[1] + A[5]*F[2]) + F[7]*(A[1]*F[1] +
            A[3]*F[0] + A[4]*F[2]) + F[8]*(A[2]*F[2] + A[4]*F[1] + A[5]*F[0]))
    return X / det(F)
def push66(F, A):
    Q = symleaf(F)
    X = np.dot(np.dot(Q, A), Q.T)
    return X / det(F)
def inv(A):
    """Computes the inverse of A"""
    if A.size == 6:
        X = zeros(6)
        X[0] = (-(A[0]*A[1] - A[3]**2)*(-A[3]*(A[4] -
                A[3]*A[5]/A[0])/(A[0]*(A[1] - A[3]**2/A[0])) +
                A[5]/A[0])*(A[3]*(A[4] - A[3]*A[5]/A[0])/(A[0]*(A[1] -
                A[3]**2/A[0])) - A[5]/A[0])/(A[0]*A[1]*A[2] - A[0]*A[4]**2 -
                A[1]*A[5]**2 - A[2]*A[3]**2 + 2*A[3]*A[4]*A[5]) + 1/A[0] +
                A[3]**2/(A[0]**2*(A[1] - A[3]**2/A[0])))
        X[1] = (1/(A[1] - A[3]**2/A[0]) + (A[4] -
                A[3]*A[5]/A[0])**2*(A[0]*A[1] - A[3]**2)/((A[1] -
                A[3]**2/A[0])**2*(A[0]*A[1]*A[2] - A[0]*A[4]**2 - A[1]*A[5]**2
                - A[2]*A[3]**2 + 2*A[3]*A[4]*A[5])))
        X[2] = ((A[0]*A[1] - A[3]**2)/(A[0]*A[1]*A[2] - A[0]*A[4]**2 -
                A[1]*A[5]**2 - A[2]*A[3]**2 + 2*A[3]*A[4]*A[5]))
        X[3] = ((A[4] - A[3]*A[5]/A[0])*(A[0]*A[1] - A[3]**2)*(-A[3]*(A[4] -
                A[3]*A[5]/A[0])/(A[0]*(A[1] - A[3]**2/A[0])) +
                A[5]/A[0])/((A[1] - A[3]**2/A[0])*(A[0]*A[1]*A[2] -
                A[0]*A[4]**2 - A[1]*A[5]**2 - A[2]*A[3]**2 +
                2*A[3]*A[4]*A[5])) - A[3]/(A[0]*(A[1] - A[3]**2/A[0])))
        X[4] = (-(A[4] - A[3]*A[5]/A[0])*(A[0]*A[1] - A[3]**2)/((A[1] -
                A[3]**2/A[0])*(A[0]*A[1]*A[2] - A[0]*A[4]**2 - A[1]*A[5]**2 -
                A[2]*A[3]**2 + 2*A[3]*A[4]*A[5])))
        X[5] = (-(A[0]*A[1] - A[3]**2)*(-A[3]*(A[4] -
                A[3]*A[5]/A[0])/(A[0]*(A[1] - A[3]**2/A[0])) +
                A[5]/A[0])/(A[0]*A[1]*A[2] - A[0]*A[4]**2 - A[1]*A[5]**2 -
                A[2]*A[3]**2 + 2*A[3]*A[4]*A[5]))
    elif A.size == 9:
        X = zeros(9)
        X[0] = (-(F[0]*F[4] - F[1]*F[3])*(-F[1]*(F[5] -
                F[2]*F[3]/F[0])/(F[0]*(F[4] - F[1]*F[3]/F[0])) +
                F[2]/F[0])*(F[3]*(F[7] - F[1]*F[6]/F[0])/(F[0]*(F[4] -
                F[1]*F[3]/F[0])) - F[6]/F[0])/(F[0]*F[4]*F[8] - F[0]*F[5]*F[7]
                - F[1]*F[3]*F[8] + F[1]*F[5]*F[6] + F[2]*F[3]*F[7] -
                F[2]*F[4]*F[6]) + 1/F[0] + F[1]*F[3]/(F[0]**2*(F[4] -
                F[1]*F[3]/F[0])))
        X[1] = ((F[7] - F[1]*F[6]/F[0])*(F[0]*F[4] - F[1]*F[3])*(-F[1]*(F[5] -
                F[2]*F[3]/F[0])/(F[0]*(F[4] - F[1]*F[3]/F[0])) +
                F[2]/F[0])/((F[4] - F[1]*F[3]/F[0])*(F[0]*F[4]*F[8] -
                F[0]*F[5]*F[7] - F[1]*F[3]*F[8] + F[1]*F[5]*F[6] +
                F[2]*F[3]*F[7] - F[2]*F[4]*F[6])) - F[1]/(F[0]*(F[4] -
                F[1]*F[3]/F[0])))
        X[2] = (-(F[0]*F[4] - F[1]*F[3])*(-F[1]*(F[5] -
                F[2]*F[3]/F[0])/(F[0]*(F[4] - F[1]*F[3]/F[0])) +
                F[2]/F[0])/(F[0]*F[4]*F[8] - F[0]*F[5]*F[7] - F[1]*F[3]*F[8] +
                F[1]*F[5]*F[6] + F[2]*F[3]*F[7] - F[2]*F[4]*F[6]))
        X[3] = (-(F[5] - F[2]*F[3]/F[0])*(F[0]*F[4] - F[1]*F[3])*(F[3]*(F[7] -
                F[1]*F[6]/F[0])/(F[0]*(F[4] - F[1]*F[3]/F[0])) -
                F[6]/F[0])/((F[4] - F[1]*F[3]/F[0])*(F[0]*F[4]*F[8] -
                F[0]*F[5]*F[7] - F[1]*F[3]*F[8] + F[1]*F[5]*F[6] +
                F[2]*F[3]*F[7] - F[2]*F[4]*F[6])) - F[3]/(F[0]*(F[4] -
                F[1]*F[3]/F[0])))
        X[4] = (1/(F[4] - F[1]*F[3]/F[0]) + (F[5] - F[2]*F[3]/F[0])*(F[7] -
                F[1]*F[6]/F[0])*(F[0]*F[4] - F[1]*F[3])/((F[4] -
                F[1]*F[3]/F[0])**2*(F[0]*F[4]*F[8] - F[0]*F[5]*F[7] -
                F[1]*F[3]*F[8] + F[1]*F[5]*F[6] + F[2]*F[3]*F[7] -
                F[2]*F[4]*F[6])))
        X[5] = (-(F[5] - F[2]*F[3]/F[0])*(F[0]*F[4] - F[1]*F[3])/((F[4] -
                F[1]*F[3]/F[0])*(F[0]*F[4]*F[8] - F[0]*F[5]*F[7] -
                F[1]*F[3]*F[8] + F[1]*F[5]*F[6] + F[2]*F[3]*F[7] -
                F[2]*F[4]*F[6])))
        X[6] = ((F[0]*F[4] - F[1]*F[3])*(F[3]*(F[7] -
                F[1]*F[6]/F[0])/(F[0]*(F[4] - F[1]*F[3]/F[0])) -
                F[6]/F[0])/(F[0]*F[4]*F[8] - F[0]*F[5]*F[7] - F[1]*F[3]*F[8] +
                F[1]*F[5]*F[6] + F[2]*F[3]*F[7] - F[2]*F[4]*F[6]))
        X[7] = (-(F[7] - F[1]*F[6]/F[0])*(F[0]*F[4] - F[1]*F[3])/((F[4] -
                F[1]*F[3]/F[0])*(F[0]*F[4]*F[8] - F[0]*F[5]*F[7] -
                F[1]*F[3]*F[8] + F[1]*F[5]*F[6] + F[2]*F[3]*F[7] -
                F[2]*F[4]*F[6])))
        X[8] = ((F[0]*F[4] - F[1]*F[3])/(F[0]*F[4]*F[8] - F[0]*F[5]*F[7] -
                F[1]*F[3]*F[8] + F[1]*F[5]*F[6] + F[2]*F[3]*F[7] -
                F[2]*F[4]*F[6]))
    else:
        raise NotImplementedError
    return X
def dyad(A, B):
    """Computes the outer product of A and B"""
    if A.size == 6 and B.size == 6:
        X = zeros((6,6))
        X[0,0] = A[0] * B[0]
        X[0,1] = A[0] * B[1]
        X[0,2] = A[0] * B[2]
        X[0,3] = A[0] * B[3]
        X[0,4] = A[0] * B[4]
        X[0,5] = A[0] * B[5]
        X[1,0] = A[1] * B[0]
        X[1,1] = A[1] * B[1]
        X[1,2] = A[1] * B[2]
        X[1,3] = A[1] * B[3]
        X[1,4] = A[1] * B[4]
        X[1,5] = A[1] * B[5]
        X[2,0] = A[2] * B[0]
        X[2,1] = A[2] * B[1]
        X[2,2] = A[2] * B[2]
        X[2,3] = A[2] * B[3]
        X[2,4] = A[2] * B[4]
        X[2,5] = A[2] * B[5]
        X[3,0] = A[3] * B[0]
        X[3,1] = A[3] * B[1]
        X[3,2] = A[3] * B[2]
        X[3,3] = A[3] * B[3]
        X[3,4] = A[3] * B[4]
        X[3,5] = A[3] * B[5]
        X[4,0] = A[4] * B[0]
        X[4,1] = A[4] * B[1]
        X[4,2] = A[4] * B[2]
        X[4,3] = A[4] * B[3]
        X[4,4] = A[4] * B[4]
        X[4,5] = A[4] * B[5]
        X[5,0] = A[5] * B[0]
        X[5,1] = A[5] * B[1]
        X[5,2] = A[5] * B[2]
        X[5,3] = A[5] * B[3]
        X[5,4] = A[5] * B[4]
        X[5,5] = A[5] * B[5]
    elif A.size == 3 and B.size == 3:
        X = zeros(6)
        X[0] = A[0] * B[0]
        X[1] = A[1] * B[1]
        X[2] = A[2] * B[2]
        X[3] = A[0] * B[1]
        X[4] = A[1] * B[2]
        X[5] = A[0] * B[2]
    else:
        raise NotImplementedError
    return X
def symshuffle(A, B):
    """ Computes the product Xijkl = .5 (Aik Bjl + Ail Bjk)"""
    X = zeros((6,6))
    if A.size == 6 and B.size == 6:
        X[0,0] = (A[0] * B[0] + A[0] * B[0]) / 2.
        X[0,1] = (A[3] * B[3] + A[3] * B[3]) / 2.
        X[0,2] = (A[5] * B[5] + A[5] * B[5]) / 2.
        X[0,3] = (A[0] * B[3] + A[3] * B[0]) / 2.
        X[0,4] = (A[3] * B[5] + A[5] * B[3]) / 2.
        X[0,5] = (A[0] * B[5] + A[5] * B[0]) / 2.
        X[1,0] = (A[3] * B[3] + A[3] * B[3]) / 2.
        X[1,1] = (A[1] * B[1] + A[1] * B[1]) / 2.
        X[1,2] = (A[4] * B[4] + A[4] * B[4]) / 2.
        X[1,3] = (A[3] * B[1] + A[1] * B[3]) / 2.
        X[1,4] = (A[1] * B[4] + A[4] * B[1]) / 2.
        X[1,5] = (A[3] * B[4] + A[4] * B[3]) / 2.
        X[2,0] = (A[5] * B[5] + A[5] * B[5]) / 2.
        X[2,1] = (A[4] * B[4] + A[4] * B[4]) / 2.
        X[2,2] = (A[2] * B[2] + A[2] * B[2]) / 2.
        X[2,3] = (A[5] * B[4] + A[4] * B[5]) / 2.
        X[2,4] = (A[4] * B[2] + A[2] * B[4]) / 2.
        X[2,5] = (A[5] * B[2] + A[2] * B[5]) / 2.
        X[3,0] = (A[0] * B[3] + A[0] * B[3]) / 2.
        X[3,1] = (A[3] * B[1] + A[3] * B[1]) / 2.
        X[3,2] = (A[5] * B[4] + A[5] * B[4]) / 2.
        X[3,3] = (A[0] * B[1] + A[3] * B[3]) / 2.
        X[3,4] = (A[3] * B[4] + A[5] * B[1]) / 2.
        X[3,5] = (A[0] * B[4] + A[5] * B[3]) / 2.
        X[4,0] = (A[3] * B[5] + A[3] * B[5]) / 2.
        X[4,1] = (A[1] * B[4] + A[1] * B[4]) / 2.
        X[4,2] = (A[4] * B[2] + A[4] * B[2]) / 2.
        X[4,3] = (A[3] * B[4] + A[1] * B[5]) / 2.
        X[4,4] = (A[1] * B[2] + A[4] * B[4]) / 2.
        X[4,5] = (A[3] * B[2] + A[4] * B[5]) / 2.
        X[5,0] = (A[0] * B[5] + A[0] * B[5]) / 2.
        X[5,1] = (A[3] * B[4] + A[3] * B[4]) / 2.
        X[5,2] = (A[5] * B[2] + A[5] * B[2]) / 2.
        X[5,3] = (A[0] * B[4] + A[3] * B[5]) / 2.
        X[5,4] = (A[3] * B[2] + A[5] * B[4]) / 2.
        X[5,5] = (A[0] * B[2] + A[5] * B[5]) / 2.
    else:
        raise NotImplementedError
    return X
odot = symshuffle
def symleaf(F):
    """ COMPUTE A 6X6 MANDEL MATRIX THAT IS THE SYM-LEAF TRANSFORMATION OF THE
    INPUT 3X3 MATRIX F.

    Parameters
    ----------
    F : ANY 3X3 MATRIX (IN CONVENTIONAL 3X3 STORAGE)

    Returns
    -------
    X : 6X6 MANDEL MATRIX FOR THE SYM-LEAF TRANSFORMATION MATRIX

    Notes
    -----
    IF A IS ANY SYMMETRIC TENSOR, AND IF {A} IS ITS 6X1 MANDEL ARRAY, THEN THE
    6X1 MANDEL ARRAY FOR THE TENSOR B=F.A.TRANSPOSE[F] MAY BE COMPUTED BY

                          {B}=[FF]{A}

    IF F IS A DEFORMATION F, THEN B IS THE "PUSH" (SPATIAL) TRANSFORMATION OF
    THE REFERENCE TENSOR A IF F IS Inverse[F], THEN B IS THE "PULL"
    (REFERENCE) TRANSFORMATION OF THE SPATIAL TENSOR A, AND THEREFORE B WOULD
    BE Inverse[FF]{A}.

    IF F IS A ROTATION, THEN B IS THE ROTATION OF A, AND
    FF WOULD BE BE A 6X6 ORTHOGONAL MATRIX, JUST AS IS F

    """
    X = zeros((6,6))
    X[0,0] = F[0] * F[0]
    X[0,1] = F[1] * F[1]
    X[0,2] = F[2] * F[2]
    X[0,3] = F[0] * F[1] + F[1] * F[0]
    X[0,4] = F[1] * F[2] + F[2] * F[1]
    X[0,5] = F[0] * F[2] + F[2] * F[0]
    X[1,0] = F[3] * F[3]
    X[1,1] = F[4] * F[4]
    X[1,2] = F[5] * F[5]
    X[1,3] = F[3] * F[4] + F[4] * F[3]
    X[1,4] = F[4] * F[5] + F[5] * F[4]
    X[1,5] = F[3] * F[5] + F[5] * F[3]
    X[2,0] = F[6] * F[6]
    X[2,1] = F[7] * F[7]
    X[2,2] = F[8] * F[8]
    X[2,3] = F[6] * F[7] + F[7] * F[6]
    X[2,4] = F[7] * F[8] + F[8] * F[7]
    X[2,5] = F[6] * F[8] + F[8] * F[6]
    X[3,0] = F[0] * F[3] + F[3] * F[0]
    X[3,1] = F[1] * F[4] + F[4] * F[1]
    X[3,2] = F[2] * F[5] + F[5] * F[2]
    X[3,3] = F[0] * F[4] + F[1] * F[3]
    X[3,4] = F[1] * F[5] + F[2] * F[4]
    X[3,5] = F[0] * F[5] + F[2] * F[3]
    X[4,0] = F[3] * F[6] + F[6] * F[3]
    X[4,1] = F[4] * F[7] + F[7] * F[4]
    X[4,2] = F[5] * F[8] + F[8] * F[5]
    X[4,3] = F[3] * F[7] + F[4] * F[6]
    X[4,4] = F[4] * F[8] + F[5] * F[7]
    X[4,5] = F[3] * F[8] + F[5] * F[6]
    X[5,0] = F[0] * F[6] + F[6] * F[0]
    X[5,1] = F[1] * F[7] + F[7] * F[1]
    X[5,2] = F[2] * F[8] + F[8] * F[2]
    X[5,3] = F[0] * F[7] + F[1] * F[6]
    X[5,4] = F[1] * F[8] + F[2] * F[7]
    X[5,5] = F[0] * F[8] + F[2] * F[6]
    return X
