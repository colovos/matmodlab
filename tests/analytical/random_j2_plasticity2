#!/usr/bin/env python3
import sys
import os
import numpy as np
import random

testname = os.path.splitext(os.path.basename(__file__))[0]

def rotation_matrix(a, theta):
    ahat = a / np.linalg.norm(a)
    part1 = np.cos(theta) * np.eye(3)
    part2 = (1.0 - np.cos(theta)) * np.outer(ahat, ahat)
    part3 = np.sin(theta) * np.array([[0.0, -ahat[2], ahat[1]],
                                      [ahat[2], 0.0, -ahat[0]],
                                      [-ahat[1], ahat[0], 0.0]])
    return part1 + part2 + part3


def fmt(x):
    if type(x) in [float, np.float64]:
        return "{0:25.15e}".format(x)
    elif type(x) in [str]:
        return "{0:>25s}".format(x)
    else:
        raise Exception("Type not recognized '{0}' of '{1}'".format(type(x), repr(x)))


def get_stress(K, G, Y, e0, e1, t):
    e0vol = e0.sum() / 3.0 * np.ones(3)
    e0dev = e0 - e0vol

    e1vol = e1.sum() / 3.0 * np.ones(3)
    e1dev = e1 - e1vol

    # Y = sqrt(3 * J2)
    j2_of_e0 = np.dot(e0dev, e0dev) / 2.0
    final_q = 2.0 * G * np.sqrt(3.0 * j2_of_e0)

    fac = min(min(t, 1.0), Y / final_q)
    p0 = 3.0 * K * e0vol * min(t, 1.0)
    s0 = 2.0 * G * e0dev * fac
    if 0.0 <= t <= 1.0:
        return p0 + s0

    # R = sqrt(2 * J2) =  mag(s) at yield
    R = np.sqrt(2.0 / 3.0) * Y
    fac = t - 1.0

    ds = 2.0 * G * e1dev * fac
    cospsi = np.dot(s0, ds) / (np.linalg.norm(s0) * np.linalg.norm(ds))
    c = np.exp(-np.linalg.norm(ds) / R)
    beta = (1.0 - c ** 2 + (1.0 - c) ** 2 * cospsi) * R / (2.0 * c * np.linalg.norm(ds))
    alpha = 2.0 * c / (1.0 + c ** 2 + (1.0 - c ** 2) * cospsi)

    p1 = p0 + 3.0 * K * e1vol * fac
    s1 =  alpha * (s0 + beta * ds)
    return p1 + s1




K = 150.0e9
G = 100.0e9
Y = 40.0e6

LAM = K - 2.0 * G / 3.0
E = 9.0 * K * G / (3.0 * K + G)
NU = (3.0 * K - 2.0 * G) / (6.0 * K + 2.0 * G)

e0 = np.zeros(3)

# Here we generate a random unit vector that will not be too close to
# the hydrostat. This is accomplished by generating a random unit vector
# in 3D space but require it to be at least theta_cutoff degrees from
# the z-axis. We then rotate the vectors such that the old z-axis is now
# the hydrostatic axis.
#
# We then compute the required magnitude of this strain so that the yield
# surface is hit exactly halfway through the first leg.

# random generation
theta_cutoff = np.radians(30.0)
theta_range = np.cos(theta_cutoff)
theta = np.arccos(theta_range * (1.0 - 2.0 * random.random()))
phi = 2.0 * np.pi * random.random()
e1 = np.array([np.sin(theta) * np.cos(phi),
               np.sin(theta) * np.sin(phi),
               np.cos(theta)])

# rotation
e1 = np.dot(rotation_matrix(np.array([-1.0, 1.0, 0.0]), np.arccos(1.0 / np.sqrt(3.0))), e1)

# scale for desired intersection with yield surface
e1dev = e1 - e1.sum() / 3.0 * np.ones(3)
fac = 2.0 * (Y / np.sqrt(12.0 * G ** 2 * np.dot(e1dev, e1dev) / 2.0))
e1 = fac * e1
e1vol = e1.sum() / 3.0 * np.ones(3)
e1dev = e1 - e1vol


# e2 is just a rotation (of random magnitude not greater than 90degrees) of
# the deviatoric part of e1 around the hydrostat while maintaining e1's
# hydrostatic strain rate.
e2_rot = np.radians(random.uniform(-60.0, 60.0))
e2 = np.dot(rotation_matrix(np.ones(3), e2_rot), e1dev) #+ e1vol



#
#
#  OUTPUT
#
#

# Print out some info about what we're doing
sys.stderr.write("Rotate by: {0}\n".format(np.degrees(e2_rot)))
sys.stderr.write("Strain table:\n")
sys.stderr.write("{0}\n".format(repr(e0)))
sys.stderr.write("{0}\n".format(repr(e1)))
sys.stderr.write("{0}\n".format(repr(e2)))


sys.stderr.write("Start - write parameter file\n")
with open(testname + "_parameters.dat", 'w') as f:
    f.write("      <K> {0} </K>\n".format(fmt(K)))
    f.write("      <G> {0} </G>\n".format(fmt(G)))
    f.write("      <Y0> {0} </Y0>\n".format(fmt(Y)))
sys.stderr.write("End - write parameter file\n")


sys.stderr.write("Start - write strain table\n")
with open(testname + "_strain_table.dat", 'w') as f:
    f.write("0   0 222 {0}{1}{2}\n".format(fmt(e0[0]), fmt(e0[1]), fmt(e0[2])))
    f.write("1   1 222 {0}{1}{2}\n".format(fmt(e1[0]), fmt(e1[1]), fmt(e1[2])))
    f.write("2 100 222 {0}{1}{2}\n".format(fmt(e1[0] + e2[0]),
                                          fmt(e1[1] + e2[1]),
                                          fmt(e1[2] + e2[2])))
sys.stderr.write("End - write strain table\n")


sys.stderr.write("Start - write answer table\n")
with open(testname + "_analytical.dat", 'w') as f:
    headers = ["TIME",
               "STRAIN_XX", "STRAIN_YY", "STRAIN_ZZ",
               "STRESS_XX", "STRESS_YY", "STRESS_ZZ"]
    f.write("".join([fmt(_) for _ in headers]) + "\n")

    for t in np.linspace(0,2,1000 + 1):
        if 0.0 <= t <= 1.0:
            fac = t
            cur_strain = (1.0 - fac) * e0 + fac * e1
        else:
            fac = t - 1.0
            cur_strain = (1.0 - fac) * e1 + fac * (e1 + e2)
        tmp = get_stress(K, G, Y, e1, e2, t)
        out = [t, cur_strain[0], cur_strain[1], cur_strain[2],
               tmp[0], tmp[1], tmp[2]]
        f.write("".join([fmt(_) for _ in out]) + "\n")
sys.stderr.write("End - write answer table\n")


sys.stderr.write("Start - write base.exdiff\n")
with open("base.exdiff", 'w') as f:
    f.write('<ExDiff ftol="1.0e-4" dtol="5.0e-5">\n')
    f.write('<Variable name="TIME"/>\n')
    f.write('<Variable name="STRESS_XX"/>\n')
    f.write('<Variable name="STRESS_YY"/>\n')
    f.write('<Variable name="STRESS_ZZ"/>\n')
    f.write('<Variable name="STRAIN_XX"/>\n')
    f.write('<Variable name="STRAIN_YY"/>\n')
    f.write('<Variable name="STRAIN_ZZ"/>\n')
    f.write('</ExDiff>\n')
sys.stderr.write("End - write base.exdiff\n")
