#!/usr/bin/env python
import os
import sys
import time
import shutil
import datetime
import argparse
import subprocess
import multiprocessing as mp

# module constants
PLATFORM = sys.platform
NOW = datetime.datetime.now()
DATE = "{0:04d}.{1:02d}.{2:02d}".format(NOW.year, NOW.month, NOW.day)
RETCODES = {-1: "NOT RUN", 0: "PASS", 1: "DIFF",
            2: "FAIL", 3: "FAIL"} # TO RUN"

# globals
LOG = None
DRYRUN = False
NOCLONE = False
NOBUILD = False
ENV = {"PATH": "/usr/local/bin:"
       "/usr/bin:/bin:/opt/epd/bin:"
       "/opt/local/sbin:/sbin:/usr/sbin"}


class Logger(object):
    def __init__(self, filepath, email_to, width=90, align="^"):
        self.filepath = filepath
        self.width = width
        self.align = align
        self.stream = open(self.filepath, "w")
        self.fileno = self.stream.fileno
        self.email_to = email_to
        self.errors = 0
        if self.email_to:
            self.email_to = [email_to[0]]
            self.email_to.append(email_to[1:])

    def write(self, text, fill="", setapart=False):
        if setapart:
            self.stream.write("{0:{fill}{align}{width}}\n".format(
                text, fill=fill, align=self.align, width=self.width))
        else:
            self.stream.write(text + "\n")
        self.flush()

    def flush(self):
        self.stream.flush()

    def error(self, text):
        self.errors += 1
        self.stream.write("*** error: {0}\n".format(text))

    def finish(self, retval):

        retcode = RETCODES.get(retval, "FAIL")

        self.stream.write("\nStatus: {0}\n".format(retcode))
        self.stream.flush()
        self.stream.close()

        # mail the log file
        if not self.email_to:
            return

        rec, cc = self.email_to
        cc = ",".join(cc)
        if cc: cc = "-c {0}".format(cc)
        subj = "[gmd Nightly: {0} - {1}]".format(PLATFORM, retcode)
        cmd = "mail -s '{1}' {2} {3} < {0}".format(self.filepath, subj, rec, cc)
        call(cmd)


def main(argv):
    global LOG, DRYRUN, ENV, NOCLONE, NOBUILD
    # Option parsing
    usage = "usage: runNightly <-Xpython> <-Sscratch> <-Ggit> [options]"
    parser = argparse.ArgumentParser(usage=usage)
    # --- required
    parser.add_argument("WORK",
        help="Path to directory to run tests [default: %(default)s]")

    # --- optional
    parser.add_argument("-X", default=sys.executable,
        help="Path to python interpreter [default: %(default)s]")
    parser.add_argument("-G", default=which("git"),
        help="Path to git executable [default: %(default)s]")
    parser.add_argument("-e", action="append", default=[],
        help="email addresses [default: %(default)s]")
    parser.add_argument("--mtls", action="append", default=[],
        help="Git repo for additional materials [default: %(default)s]")
    parser.add_argument("--tests", action="append", default=[],
        help="Git repo for additional tests [default: %(default)s]")
    parser.add_argument("-k", action="append", default=[],
        help="Keywords to pass to runtests [default: %(default)s]")
    parser.add_argument("-j", default=(mp.cpu_count() - 2),
        help="Number of processors [default: %(default)s]")
    parser.add_argument("--dryrun", action="store_true", default=False,
        help="Dry run [default: %(default)s]")
    parser.add_argument("--no-clone", action="store_true", default=False,
        help=argparse.SUPPRESS)
    parser.add_argument("--no-build", action="store_true", default=False,
        help=argparse.SUPPRESS)
    args = parser.parse_args(argv)
    DRYRUN = args.dryrun
    NOBUILD = args.no_build
    NOCLONE = NOBUILD or args.no_clone

    t0 = time.time()

    # python interpreter
    if not os.path.isfile(args.X):
        error("{0}: no such file".format(args.X))

    # scratch space
    work = os.path.realpath(args.WORK)
    if not os.path.isdir(work):
        error("{0}: no such directory".format(work))
    elif not os.access(work, os.W_OK|os.X_OK):
        error("unable to write to {0}".format(work))

    # git
    if not os.path.isfile(args.G):
        error("{0}: no such file (git)".format(args.G))

    # check for previous errors
    error(stop_if_error=True)

    # directory to run tonights tests
    nightly = os.path.join(work, "GMD_Nightly/{0}".format(DATE))
    current = os.path.join(work, "GMD_Nightly/Current")

    # remove old stuff, create new
    if not NOCLONE:
        remove_if_exists(nightly, d=True)
        remove_if_exists(current)
        os.makedirs(nightly, 0750)
        os.symlink(nightly, current)

    # gmd directory and log file
    LOG = Logger(os.path.join(nightly, "gmd_testing.log"), args.e)
    LOG.write("#", fill="#", setapart=True)
    LOG.write("GMD Nightly Testing", fill=" ", setapart=True)
    LOG.write("Date: {0}\n".format(NOW.strftime("%A %B %d, %Y")))
    LOG.write("Time: {0}\n".format(NOW.strftime("%H:%M:%S")))
    LOG.write("Platform: {0}\n".format(PLATFORM))
    LOG.write("#", fill="#", setapart=True)

    # clone git repositories
    gmd_repo = "git@github.com:tjfulle/gmd.git"
    clone_git_repos(gmd_repo, args.mtls, args.tests, nightly, args.G)

    # now look for material directories for when setting up gmd
    mtldirs = []
    for (i, mtldir) in enumerate(args.mtls):
        for (dirname, dirs, files) in os.walk(mtldir):
            if "makemf.py" in files:
                mtldirs.append(dirname)
                break
        else:
            LOG.error("{0}: expected to find "
                      "makemf.py".format(os.path.basename(mtldir)))

    # set up gmd
    gmd_d = os.path.join(nightly, "gmd")
    path = [os.path.join(gmd_d, "toolset"), os.path.dirname(args.X), ENV["PATH"]]
    ENV["PATH"] = os.pathsep.join(path)
    LOG.write("\n\n")
    text = "Setting up gmd with {0}".format(args.X)
    LOG.write(text, fill="*", setapart=True)
    cmd = "{0} {1}/toolset/setup.py {2} {3}".format(args.X, gmd_d,
        " ".join("--mtldirs={0}".format(m) for m in mtldirs),
        " ".join("--testdirs={0}".format(t) for t in args.tests))
    setup = call(cmd, stream=LOG)
    if setup != 0:
        LOG.error("failed to setup gmd with {0}".format(args.X))
        LOG.finish(2)
        sys.exit(2)

    # build
    LOG.write("\n\n")
    text = "Building gmd with {0}".format(args.X)
    LOG.write(text, fill="*", setapart=True)
    cmd = os.path.join(gmd_d, "toolset/buildmtls")
    build = call(cmd, stream=LOG)
    if build != 0:
        LOG.error("failed to build with {0}".format(args.X))
        LOG.finish(2)
        sys.exit(2)

    # run the tests
    LOG.write("\n\n")
    text = "Testing gmd with {0}".format(args.X)
    LOG.write(text, fill="*", setapart=True)
    d = os.path.join(nightly, "TestResults.{0}_{1}".format(
        PLATFORM, os.path.basename(args.X)))
    cmd = "{0} -F -D{1} {2} -j{3}".format(
        os.path.join(gmd_d, "toolset/runtests"), d,
        " ".join("-k{0}".format(k) for k in args.k), args.j)
    runtests = call(cmd, stream=LOG)

    retcode = RETCODES.get(runtests, "FAIL")
    LOG.write("Testing completed with return code: {0}\n".format(retcode))

    tf = time.time()
    LOG.write("\n\n")
    LOG.write("#", fill="#", setapart=True)
    text = "TESTING COMPLETED"
    LOG.write(text, fill=" ", setapart=True)
    LOG.write("Total time: {0:.2f}\n".format(float(tf - t0)))
    LOG.write("#", fill="#", setapart=True)
    LOG.finish(runtests)

    return


def error(message=None, errors=[0], stop_if_error=False):
    if message is None:
        return errors[0]
    if stop_if_error:
        if error[0]:
            sys.stdout.write("stopping due to previous errors\n")
            sys.exit(2)
        return
    sys.stderr.write("*** error: {0}\n".format(message))
    errors[0] += 1


def which(name):
    for d in os.getenv("PATH", "").split(os.pathsep):
        exe = os.path.join(d, name)
        if os.path.isfile(exe):
            return exe


def remove_if_exists(path, d=False):
    remove = shutil.rmtree if d else os.remove
    try: remove(path)
    except OSError: pass


def clone_git_repos(gmd_repo, mtls, tests, rootd, git):
    """Clone the git repos to rootd

    """
    # clone git repositories
    cwd = os.getcwd()
    os.chdir(rootd)

    cmd = "{0} clone {1} {2}"

    # get gmd
    name = "gmd"
    LOG.write("\n\n")
    text = "Cloning from {0}".format(gmd_repo)
    LOG.write(text, fill="*", setapart=True)
    clone = call(cmd.format(git, gmd_repo, name), stream=LOG)
    if clone != 0:
        LOG.error("failed to clone {0}\n".format(git_repo))
        finish(2)
        sys.exit(2)

    # materials
    for (i, git_repo) in enumerate(mtls):
        name = os.path.basename(git_repo).rstrip(".git")
        LOG.write("\n\n")
        text = "Cloning from {0}".format(git_repo)
        LOG.write(text, fill="*", setapart=True)
        clone = call(cmd.format(git, git_repo, name), stream=LOG)
        if clone != 0:
            LOG.error("failed to clone {0}\n".format(git_repo))
            finish(2)
            sys.exit(2)
        mtls[i] = os.path.join(rootd, name)

    # tests
    for (i, git_repo) in enumerate(tests):
        name = os.path.basename(git_repo).rstrip(".git")
        LOG.write("\n\n")
        text = "Cloning from {0}".format(git_repo)
        LOG.write(text, fill="*", setapart=True)
        clone = call(cmd.format(git, git_repo, name), stream=LOG)
        if clone != 0:
            LOG.error("failed to clone {0}\n".format(git_repo))
            finish(2)
            sys.exit(2)
        tests[i] = os.path.join(rootd, name)

    os.chdir(cwd)

    return


def call(cmd, stream=None):
    if DRYRUN:
        print cmd
        return 0
    if NOCLONE and "clone" in cmd:
        return 0
    if NOBUILD and "buildmtls" in cmd:
        return 0
    if stream is None:
        stream = subprocess.PIPE
    return subprocess.call(cmd, shell=True, env=ENV,
                           stdout=stream, stderr=subprocess.STDOUT)

if __name__ == "__main__":
    main(sys.argv[1:])
