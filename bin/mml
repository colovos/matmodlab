#!/usr/bin/env bash
# set up python environment

usage()
{
cat << EOF
usage: mml [-h|help] <command> [<args>]

The mml commands are:
  build    Build fortran libraries
  clean    Clean simulation and build files generated by matmodlab
  config   Run the cofiguration tool
  convert  Convert matmodlab 1.x xml input to matmodlab 2.x python input (limited)
  python   Launch a python interpreter with the matmodlab environment
  run      Run a simulation.  [<args>] should take form <filename> [options].
           Any [options] appearing before <filename> will be processed by the
           python interpreter and not mml, likely resulting in undesired behavior.
  test     Run tests
  view     Launch the matmodlab viewer

See 'mml help <command>' to read about a specific subcommand.

EOF
}

getprog() {
    local x=$(trim "$1")
    local f="$MML_ROOT/bin/mml-$x"
    if [ -f $f ]; then
	echo -n "$f"
	exit 0
    else
	if [ ! -z "$x" ]; then
	    echo -n "error: mml: $x: unrecognized command"
	fi
	exit 1
    fi
}

trim() {
    echo -n $(echo "$1" | sed "s/\(^ *\| *\$\)//g")
}

resolvelinks() {
    # resolvelinks taken from a script in sage (sagemath.org)
    # $in is what still needs to be converted (normally has no starting slash)
    in="$1"
    # $out is the part which is converted (normally ends with trailing slash)
    out="./"

    # Move stuff from $in to $out
    while [ -n "$in" ]; do
        # Normalize $in by replacing consecutive slashes by one slash
        while { in_single_slash=${in//\/\//\/}; [ "$in" != "$in_single_slash" ]; }; do
            in=$in_single_slash
        done

        # If $in starts with a slash, remove it and set $out to the root
        in_without_slash=${in/#\//}
        if [ "$in" != "$in_without_slash" ]; then
            in=$in_without_slash
            out="/"
            continue
        fi

        # Check that the directory $out exists by trying to cd to it.
        # If this fails, then cd will show an error message (unlike
        # test -d "$out"), so no need to be more verbose.
        ( cd "$out" ) || return $?

        # Get the first component of $in
        f=${in%%/*}

        # If it is not a symbolic link, simply move it to $out
        if [ ! -L "$out$f" ]; then
            in=${in#"$f"}
            out="$out$f"

            # If the new $in starts with a slash, move it to $out
            in_without_slash=${in/#\//}
            if [ "$in" != "$in_without_slash" ]; then
                in=$in_without_slash
                out="$out/"
            fi
            continue
        fi

        # Now resolve the symbolic link "$f"
        f_resolved=$(readlink -n "$out$f" 2>/dev/null)
        status=$?
        # status 127 means readlink could not be found.
        if [ $status -eq 127 ]; then
            # We don't have "readlink", try a stupid "ls" hack instead.
            # This will fail if we have filenames like "a -> b".
            fls=$(ls -l "$out$f" 2>/dev/null)
            status=$?
            f_resolved=${fls##*-> }

            # If $fls equals $f_resolved, then certainly
            # something is wrong
            if [ $status -eq 0 -a "$fls" = "$f_resolved" ]; then
                echo >&2 "Cannot parse output from ls -l '$out$f'"
                return 1
            fi
        fi
        if [ $status -ne 0 ]; then
            echo >&2 "Cannot read symbolic link '$out$f'"
            return $status
        fi

        # In $in, replace $f by $f_resolved (leave $out alone)
        in=${in/#"$f"/"$f_resolved"}
    done

    # Return $out
    echo -n "$out"
}

# If MML_ROOT is not given, find it out from $0
if [ -z "$MML_ROOT" ];  then
    # Get the path to $0 (this shell script) with all symbolic links
    # resolved
    d=$(resolvelinks "$0") || d="$0"

    # Get the directory component
    d="${d%/*}"
    d=$(cd "$d" && pwd -P)
    MML_ROOT="$(dirname "$d")"
fi

# Make MML_ROOT absolute
MML_ROOT=$(cd "$MML_ROOT" && pwd -P)
if [ $? -ne 0 ]; then
    echo >&2 "$0: cannot determine MML_ROOT directory"
    exit 1
fi

# set needed environment variables
export MML_ROOT
export PATH="$MML_ROOT/bin:$PATH"
export PYTHONPATH="$MML_ROOT:$PYTHONPATH"

# option parsing - only -h is interpreted by this top level script, all other
# options are passed through.
while getopts "h" OPTION
do
     case $OPTION in
         h)
             usage
             exit 0
             ;;
         ?)
	     echo "$OPTION option not recognized"
             usage
             exit 1
             ;;
     esac
done

# positional parameters
cmd=$(trim "$1")
shift
if [ "$cmd" == "help" ];
then
    cmd=$(trim "$1")
    if [ "$cmd" == "" ];
    then
        usage
        exit 0
    fi
    set -- "-h"
fi

# get the actual program name
X=$(getprog "$cmd")
if [ $? -ne 0 ]; then
    if [ ! -z "$X" ];
    then
	echo "mml: '$cmd' is not a mml command.  See 'mml -h'."
    else
	usage
    fi
    exit 1
fi

# run the program
$X "$@"
