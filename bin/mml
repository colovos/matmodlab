#!/usr/bin/env python
# set up python environment
import os
import sys
from subprocess import Popen
from os.path import dirname, isfile, join, realpath, split

D, F = split(realpath(__file__))
sys.path.insert(0, dirname(D))
from utils.misc import load_file
from core.product import ROOT_D, CORE_D, UTL_D

# --- check prereqs
errors = []
(major, minor, micro, relev, ser) = sys.version_info
if (major != 3 and major != 2) or (major == 2 and minor < 7):
    errors.append("python >= 2.7 required")
    errors.append("  {0} provides {1}.{2}.{3}".format(
        sys.executable, major, minor, micro))

# --- numpy
try: import numpy
except ImportError: errors.append("numpy not found")

# --- scipy
try: import scipy
except ImportError: errors.append("scipy not found")

# check prerequisites
if errors:
    sys.exit("*** error: matmodlab could not run due to the "
             "following errors:\n  {0}".format("\n  ".join(errors)))

import matmodlab as matmodlab
import core.builder as builder
import utils.mmlclean as clean
import core.configurer as configurer
import utils.mmlconv as mmlconv
import core.tester as tester
import core.plotter as plotter

commands = {"build": builder,
            "clean": clean,
            "config": configurer,
            "convert": mmlconv,
            "helper": matmodlab,
            "run": None,
            "test": tester,
            "view": plotter}

usage = """\
usage: mml [-h|help] <command> [<args>]

The mml commands are:
  build    Build fortran libraries
  clean    Clean simulation and build files generated by matmodlab
  config   Run the cofiguration tool
  convert  Convert matmodlab 1.x xml input to matmodlab 2.x python input (limited)
  run      Run a simulation
  test     Run tests
  view     Launch the matmodlab viewer

See 'mml help <command>' to read about a specific subcommand.
"""

def envins(E, x, i=0):
    e = os.getenv(E, "").split(os.pathsep)
    e.insert(i, x)
    return os.pathsep.join(e)

def main(argv=None):
    if argv is None:
        argv = sys.argv[1:]

    # if no arguments given, exit
    if not argv:
        sys.exit(usage)

    # get first argument, check if help requested
    x, argv = argv[0], argv[1:]
    if x in ("-h", "--help"):
        sys.exit(usage)

    # check for command specific help
    if x == "help":
        if not argv:
            sys.exit(usage)
        x, argv = argv[0], ["-h"]

    # at this point, x is a mml command.  get the specific file to load
    try:
        module = commands[x]
    except KeyError:
        sys.exit("mml: '{0}' is not a mml command.  See 'mml -h'.".format(x))

    if module:
        sys.argv = ["mml {0}".format(x)] + argv
        sys.exit(module.main(argv=argv))

    # to get to this point, the command was 'run'. we use the python
    # interpreter to call the file argument directly - unless a help was
    # requested, then we print the help message.
    assert x == "run"
    if not argv or argv[0] in ("-h", "--help"):
        f = join(ROOT_D, "matmodlab.py")
        sys.argv = ["mml {0}".format(x)] + ["-h"]
        module = commands["helper"]
        sys.exit(module.main(argv=sys.argv))

    # first argument should be a file name, otherwise, positional arguments
    # will be interpreted by the python executable and not mml
    filename = argv[0]
    if not isfile(filename):
        filename = filename.rstrip(".") + ".py"
    if not isfile(filename):
        sys.exit("*** error: mml run: {0}: expected first argument to be "
                 "a file name".format(argv[0]))
    argv[0] = filename

    command = "{0} {1}".format(sys.executable, " ".join(argv))

    # set the (minimal) environment in which the simulation will be run
    environment = {}
    environment["FC"] = os.getenv("FC", "gfortran")
    environment["PATH"] = envins("PATH", D)
    environment["DISPLAY"] = os.getenv("DISPLAY", ":0")
    environment["PYTHONPATH"] = envins("PYTHONPATH", ROOT_D)
    if os.getenv("MATMODLABRC", "") is not "":
        environment["MATMODLABRC"] = os.getenv("MATMODLABRC")

    proc = Popen(command.split(), env=environment)
    proc.wait()
    sys.exit(proc.returncode)


if __name__ == "__main__":
    main()
