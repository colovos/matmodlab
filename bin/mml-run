#!/bin/bash
if [ -z "$MML_ROOT" ];  then
    echo >&2 "*** error: mml-run: MML_ROOT environment variable not set"
    echo >&2 "this script should be called through matmodlab/bin/mml"
    echo >&2 "and not directly"
    exit 1
fi

PYEXE=$(which python)
PYFILE=$MML_ROOT/matmodlab.py

trim() {
    echo -n $(echo "$1" | sed "s/\(^ *\| *\$\)//g")
}

# mml-run calls the python script directly. But first, we want all file
# arguments before other options (and check for help request). This is so that
# the script parses command line arguments - and not the python interpreter.
argv=()
opts=()
for var in "$@"
do
    var=$(trim "$var")
    if [ -f "$var" ]; then
	argv+=$var
    elif [ "$var" == "--help" -o "$var" == "-h" ]; then
	# mml-run typically operates directly on a python file - which uses
	# the @matmodlab decorator in matmodlab.py to parse command line
	# arguments, here we call matmodlab.py directly for the help message
	$PYEXE $PYFILE -h
        exit 0
    elif [ "$var" == "" ]; then
	continue
    else
	opts+=("$var")
    fi
done

if [ "${#opts[@]}" -gt 0 ]; then
    argv+=("$opts")
fi
set -- "${argv[@]}"

$PYEXE "$@"
